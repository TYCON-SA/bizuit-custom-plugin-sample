trigger:
  branches:
    include:
      - main
  paths:
    include:
      - src/**
      - plugin.json
      - package.json
      - database/**

pr: none

pool:
  vmImage: 'ubuntu-latest'

variables:
  dotnetVersion: '9.0.x'
  nodeVersion: '20.x'

stages:
  - stage: Build
    displayName: 'Build Plugin Package'
    jobs:
      - job: BuildPlugin
        displayName: 'Build and Package Plugin'
        steps:
          - checkout: self
            fetchDepth: 0
            persistCredentials: true

          - task: UseDotNet@2
            displayName: 'Setup .NET SDK'
            inputs:
              packageType: 'sdk'
              version: '$(dotnetVersion)'

          - task: NodeTool@0
            displayName: 'Setup Node.js'
            inputs:
              versionSpec: '$(nodeVersion)'

          - script: npm install
            displayName: 'Install npm dependencies'

          - script: |
              COMMIT_HASH="$(Build.SourceVersion)"
              SHORT_HASH="${COMMIT_HASH:0:7}"
              BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")

              echo "##vso[task.setvariable variable=commitHash]$COMMIT_HASH"
              echo "##vso[task.setvariable variable=shortHash]$SHORT_HASH"
              echo "##vso[task.setvariable variable=buildDate]$BUILD_DATE"

              echo "Commit: $SHORT_HASH"
              echo "Build Date: $BUILD_DATE"
            displayName: 'Get build metadata'

          - script: |
              # Pull latest changes to get version commits (they have [skip ci] so won't be in checkout)
              git pull origin main --rebase || true

              # Validate plugin.json is valid JSON before proceeding
              echo "üìã Validating plugin.json..."
              if ! jq empty plugin.json 2>/dev/null; then
                echo "‚ùå ERROR: plugin.json is not valid JSON!"
                echo "Content:"
                cat plugin.json
                echo ""
                echo "Attempting to restore from plugin.json.example..."
                if [ -f "plugin.json.example" ] && jq empty plugin.json.example 2>/dev/null; then
                  cp plugin.json.example plugin.json
                  echo "‚úÖ Restored from plugin.json.example"
                else
                  echo "‚ùå FATAL: Cannot recover plugin.json"
                  exit 1
                fi
              fi
              echo "‚úÖ plugin.json is valid JSON"

              # Read current version from plugin.json (this is the source of truth)
              CURRENT_VERSION=$(jq -r '.version // "0.0.0"' plugin.json)
              echo "Current version in plugin.json: $CURRENT_VERSION"

              # Validate current version format
              if [ -z "$CURRENT_VERSION" ] || ! [[ "$CURRENT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                NEW_VERSION="1.0.0"
                echo "Invalid or missing version! Starting at v1.0.0"
              else
                # Increment PATCH from current version
                IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
                PATCH=$((PATCH + 1))
                NEW_VERSION="$MAJOR.$MINOR.$PATCH"
                echo "Auto-increment: $CURRENT_VERSION -> $NEW_VERSION"
              fi

              echo "##vso[task.setvariable variable=pluginVersion]$NEW_VERSION"

              # Update plugin.json with new version (with validation)
              if jq --arg version "$NEW_VERSION" '.version = $version' plugin.json > plugin.tmp.json && [ -s plugin.tmp.json ]; then
                mv plugin.tmp.json plugin.json
                echo "‚úÖ Updated plugin.json to version $NEW_VERSION"
              else
                echo "‚ùå ERROR: Failed to update version in plugin.json"
                rm -f plugin.tmp.json
                exit 1
              fi
            displayName: 'Calculate version'

          - script: |
              # Validate plugin.json before reading metadata
              if ! jq empty plugin.json 2>/dev/null; then
                echo "‚ùå ERROR: plugin.json is not valid JSON!"
                exit 1
              fi

              # Read metadata
              PLUGIN_NAME=$(jq -r '.name // "unknown"' plugin.json)
              PLUGIN_DESC=$(jq -r '.description // "Backend plugin"' plugin.json)
              PLUGIN_AUTHOR=$(jq -r '.author // "BIZUIT"' plugin.json)

              # Derive project name from entryPoint (e.g., "MyPlugin.dll" -> "MyPlugin")
              ENTRY_POINT=$(jq -r '.entryPoint // ""' plugin.json)

              if [ -z "$ENTRY_POINT" ] || [ "$ENTRY_POINT" = "null" ]; then
                echo "‚ùå ERROR: entryPoint not found in plugin.json!"
                echo "Content of plugin.json:"
                cat plugin.json
                exit 1
              fi

              PROJECT_NAME="${ENTRY_POINT%.dll}"

              echo "##vso[task.setvariable variable=pluginName]$PLUGIN_NAME"
              echo "##vso[task.setvariable variable=pluginDesc]$PLUGIN_DESC"
              echo "##vso[task.setvariable variable=pluginAuthor]$PLUGIN_AUTHOR"
              echo "##vso[task.setvariable variable=projectName]$PROJECT_NAME"

              echo "Plugin: $PLUGIN_NAME"
              echo "Project: $PROJECT_NAME"
              echo "Description: $PLUGIN_DESC"
              echo "Entry Point: $ENTRY_POINT"
            displayName: 'Read plugin metadata'

          - script: |
              echo "üìù Preparing plugin.json for CI/CD deployment..."
              echo "This ensures NO credentials are included in the deployment ZIP"

              # Backup current plugin.json (has updated version)
              cp plugin.json plugin.version-updated.json

              # Copy plugin.json.example as base (without credentials)
              if [ -f "plugin.json.example" ]; then
                # Validate plugin.json.example is valid JSON
                if jq empty plugin.json.example 2>/dev/null; then
                  cp plugin.json.example plugin.json
                  echo "‚úÖ Copied plugin.json.example ‚Üí plugin.json"
                else
                  echo "‚ùå ERROR: plugin.json.example is not valid JSON!"
                  cat plugin.json.example
                  exit 1
                fi
              else
                echo "‚ö†Ô∏è  Warning: plugin.json.example not found, using existing plugin.json"
              fi

              # Restore version from backup (with validation)
              VERSION=$(jq -r '.version' plugin.version-updated.json)
              if jq --arg version "$VERSION" '.version = $version' plugin.json > plugin.tmp.json && [ -s plugin.tmp.json ]; then
                mv plugin.tmp.json plugin.json
                echo "‚úÖ Restored version: $VERSION"
              else
                echo "‚ùå ERROR: Failed to restore version"
                rm -f plugin.tmp.json
                exit 1
              fi

              # Sanitize defaultSettings (empty all values for security)
              if [ -f "scripts/sanitize-plugin-json.mjs" ]; then
                node scripts/sanitize-plugin-json.mjs
                echo "‚úÖ Sanitized defaultSettings (all values emptied)"
              else
                echo "‚ö†Ô∏è  Warning: sanitize script not found, skipping sanitization"
              fi

              # Final validation
              if ! jq empty plugin.json 2>/dev/null; then
                echo "‚ùå ERROR: plugin.json is corrupted after sanitization!"
                exit 1
              fi

              # Show final plugin.json for verification
              echo ""
              echo "üìã Final plugin.json:"
              cat plugin.json
              echo ""
            displayName: 'Sanitize plugin.json (remove credentials)'

          - script: |
              echo "Building plugin..."

              # Validate projectName is set
              if [ -z "$(projectName)" ]; then
                echo "‚ùå ERROR: projectName variable is empty!"
                exit 1
              fi

              dotnet publish src/$(projectName)/$(projectName).csproj -c Release -o publish

              echo "Build completed"
              ls -la publish/
            displayName: 'Build and publish plugin'

          - script: |
              echo "Including database migrations in package..."
              if [ -d "database" ]; then
                mkdir -p publish/migrations
                MIGRATION_COUNT=0
                for f in database/[0-9][0-9][0-9]_*.sql; do
                  if [ -f "$f" ]; then
                    cp "$f" publish/migrations/
                    echo "  + migrations/$(basename "$f")"
                    MIGRATION_COUNT=$((MIGRATION_COUNT + 1))
                  fi
                done
                echo "Included $MIGRATION_COUNT migration script(s)"
              else
                echo "No database/ directory found, skipping migrations"
              fi
            displayName: 'Include migrations in package'

          - script: |
              PLUGIN_NAME="$(pluginName)"
              VERSION="$(pluginVersion)"
              SHORT_HASH="$(shortHash)"
              COMMIT_HASH="$(commitHash)"
              BUILD_DATE="$(buildDate)"

              ZIP_NAME="${PLUGIN_NAME}.${VERSION}-${SHORT_HASH}.zip"

              mkdir -p dist

              # Get release notes from git commit message
              RELEASE_NOTES=$(git log -1 --pretty=%B)

              # Get repository URL from git remote
              REPO_URL=$(git remote get-url origin 2>/dev/null | sed 's/\.git$//' || echo "")

              # Build URL for Azure DevOps
              BUILD_URL="$(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"

              echo "Adding metadata to plugin.json:"
              echo "  - commitHash: $SHORT_HASH"
              echo "  - buildDate: $BUILD_DATE"
              echo "  - buildUrl: $BUILD_URL"
              echo "  - repositoryUrl: $REPO_URL"

              # Enrich plugin.json with all metadata (with validation)
              if jq --arg commitHash "$COMMIT_HASH" \
                 --arg buildDate "$BUILD_DATE" \
                 --arg releaseNotes "$RELEASE_NOTES" \
                 --arg repositoryUrl "$REPO_URL" \
                 --arg buildUrl "$BUILD_URL" \
                 '. + {commitHash: $commitHash, buildDate: $buildDate, releaseNotes: $releaseNotes, repositoryUrl: $repositoryUrl, buildUrl: $buildUrl}' \
                 plugin.json > plugin.enriched.json && [ -s plugin.enriched.json ]; then
                echo "‚úÖ Enriched plugin.json with metadata"
              else
                echo "‚ùå ERROR: Failed to enrich plugin.json"
                rm -f plugin.enriched.json
                exit 1
              fi

              # Create ZIP with published files + enriched plugin.json
              cd publish
              cp ../plugin.enriched.json ./plugin.json
              zip -r "../dist/${ZIP_NAME}" .
              cd ..

              echo "##vso[task.setvariable variable=zipName]$ZIP_NAME"

              echo "Created: dist/${ZIP_NAME}"
              ls -la dist/

              # Verify plugin.json in ZIP is not empty
              echo ""
              echo "üìã Verifying plugin.json in ZIP:"
              unzip -p "dist/${ZIP_NAME}" plugin.json | head -20
            displayName: 'Create ZIP package with metadata'

          - task: PublishPipelineArtifact@1
            displayName: 'Publish artifact'
            inputs:
              targetPath: 'dist'
              artifact: '$(pluginName)-$(pluginVersion)'
              publishLocation: 'pipeline'

          - script: |
              echo "üìù Committing version update..."

              # IMPORTANT: Restore the ORIGINAL plugin.json structure before committing
              # We need to commit plugin.json with the new version but WITHOUT defaultSettings
              # (defaultSettings should only exist in plugin.json.example)

              # Create a clean plugin.json with just the essential fields
              jq '{name, version, description, author, entryPoint, pluginClass, requiresDatabase, migrations}' plugin.version-updated.json > plugin.json

              # Validate before committing
              if ! jq empty plugin.json 2>/dev/null || [ ! -s plugin.json ]; then
                echo "‚ùå ERROR: plugin.json is invalid before commit!"
                cat plugin.json
                exit 1
              fi

              echo "üìã plugin.json to commit:"
              cat plugin.json

              git config user.name "Azure Pipelines"
              git config user.email "azure-pipelines@dev.azure.com"

              git add plugin.json

              if git diff --staged --quiet; then
                echo "‚ö†Ô∏è No version changes to commit"
              else
                git commit -m "chore: bump version to $(pluginVersion) [skip ci]"

                echo "üì§ Pushing changes to repository..."

                # Extract branch name from refs/heads/main -> main
                BRANCH_NAME=$(echo "$(Build.SourceBranch)" | sed 's|refs/heads/||')
                echo "Branch: $BRANCH_NAME"

                # Push with explicit error handling
                if git push origin HEAD:$BRANCH_NAME; then
                  echo "‚úÖ Version update committed and pushed successfully"
                else
                  echo "‚ùå Failed to push changes"
                  echo "This might be a permissions issue. Check pipeline settings:"
                  echo "  - Project Settings ‚Üí Repositories ‚Üí Security"
                  echo "  - Grant 'Contribute' permission to Build Service"
                  exit 1
                fi
              fi
            displayName: 'Commit version update'
            condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))

          - script: |
              echo "=============================================="
              echo "  Plugin Package Created Successfully!"
              echo "=============================================="
              echo ""
              echo "Plugin: $(pluginName)"
              echo "Version: $(pluginVersion)"
              echo "Commit: $(shortHash)"
              echo "Build Date: $(buildDate)"
              echo ""
              echo "Artifact: $(zipName)"
              echo ""
              echo "Metadata included:"
              echo "  - commitHash: $(shortHash)"
              echo "  - buildDate: $(buildDate)"
              echo "  - releaseNotes: (from commit message)"
              echo "  - buildUrl: (Azure DevOps build link)"
              echo "  - repositoryUrl: (from git remote)"
              echo ""
              echo "Installation:"
              echo "  1. Download artifact from this pipeline"
              echo "  2. Go to Admin Panel > Plugins > Upload Plugin"
              echo "  3. Upload the ZIP file"
              echo "  4. Configure connection string if needed"
              echo "  5. Activate the plugin"
              echo ""
              echo "API Endpoints will be available at:"
              echo "  /api/plugins/$(pluginName)/*"
              echo "=============================================="
            displayName: 'Summary'
