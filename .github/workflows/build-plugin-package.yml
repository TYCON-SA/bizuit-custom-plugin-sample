name: Build Plugin Package

on:
  push:
    branches:
      - main
    paths:
      - 'src/**'
      - 'plugin.json'
      - 'package.json'
  workflow_dispatch:
    inputs:
      version:
        description: 'Package version (leave empty to auto-increment)'
        required: false
        type: string

jobs:
  build-plugin-package:
    name: Build Plugin ZIP
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install npm dependencies
        run: npm install

      - name: Get build metadata
        id: build_metadata
        run: |
          COMMIT_HASH="${{ github.sha }}"
          SHORT_HASH="${COMMIT_HASH:0:7}"
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")

          echo "commit_hash=$COMMIT_HASH" >> $GITHUB_OUTPUT
          echo "short_hash=$SHORT_HASH" >> $GITHUB_OUTPUT
          echo "build_date=$BUILD_DATE" >> $GITHUB_OUTPUT

          echo "Commit: $SHORT_HASH"
          echo "Build Date: $BUILD_DATE"

      - name: Calculate version
        id: version
        run: |
          # Pull latest changes to get version commits (they have [skip ci] so won't be in checkout)
          git pull origin main --rebase || true

          # Validate plugin.json is valid JSON before proceeding
          echo "üìã Validating plugin.json..."
          if ! jq empty plugin.json 2>/dev/null; then
            echo "‚ùå ERROR: plugin.json is not valid JSON!"
            echo "Content:"
            cat plugin.json
            echo ""
            echo "Attempting to restore from plugin.json.example..."
            if [ -f "plugin.json.example" ] && jq empty plugin.json.example 2>/dev/null; then
              cp plugin.json.example plugin.json
              echo "‚úÖ Restored from plugin.json.example"
            else
              echo "‚ùå FATAL: Cannot recover plugin.json"
              exit 1
            fi
          fi
          echo "‚úÖ plugin.json is valid JSON"

          # Read current version from plugin.json (this is the source of truth)
          CURRENT_VERSION=$(jq -r '.version // "0.0.0"' plugin.json)
          echo "Current version in plugin.json: $CURRENT_VERSION"

          # If manual version provided, use it
          if [ -n "${{ github.event.inputs.version }}" ]; then
            NEW_VERSION="${{ github.event.inputs.version }}"
            echo "Using manual version: $NEW_VERSION"
          else
            # Validate current version format
            if [ -z "$CURRENT_VERSION" ] || ! [[ "$CURRENT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              NEW_VERSION="1.0.0"
              echo "Invalid or missing version! Starting at v1.0.0"
            else
              # Increment PATCH from current version
              IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
              PATCH=$((PATCH + 1))
              NEW_VERSION="$MAJOR.$MINOR.$PATCH"
              echo "Auto-increment: $CURRENT_VERSION -> $NEW_VERSION"
            fi
          fi

          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

          # Update plugin.json with new version (with validation)
          if jq --arg version "$NEW_VERSION" '.version = $version' plugin.json > plugin.tmp.json && [ -s plugin.tmp.json ]; then
            mv plugin.tmp.json plugin.json
            echo "‚úÖ Updated plugin.json to version $NEW_VERSION"
          else
            echo "‚ùå ERROR: Failed to update version in plugin.json"
            rm -f plugin.tmp.json
            exit 1
          fi

      - name: Read plugin metadata
        id: plugin_meta
        run: |
          # Validate plugin.json before reading metadata
          if ! jq empty plugin.json 2>/dev/null; then
            echo "‚ùå ERROR: plugin.json is not valid JSON!"
            exit 1
          fi

          PLUGIN_NAME=$(jq -r '.name // "unknown"' plugin.json)
          PLUGIN_DESC=$(jq -r '.description // "Backend plugin"' plugin.json)
          PLUGIN_AUTHOR=$(jq -r '.author // "BIZUIT"' plugin.json)

          # Derive project name from entryPoint (e.g., "MyPlugin.dll" -> "MyPlugin")
          ENTRY_POINT=$(jq -r '.entryPoint // ""' plugin.json)

          if [ -z "$ENTRY_POINT" ] || [ "$ENTRY_POINT" = "null" ]; then
            echo "‚ùå ERROR: entryPoint not found in plugin.json!"
            echo "Content of plugin.json:"
            cat plugin.json
            exit 1
          fi

          PROJECT_NAME="${ENTRY_POINT%.dll}"

          echo "name=$PLUGIN_NAME" >> $GITHUB_OUTPUT
          echo "description=$PLUGIN_DESC" >> $GITHUB_OUTPUT
          echo "author=$PLUGIN_AUTHOR" >> $GITHUB_OUTPUT
          echo "project_name=$PROJECT_NAME" >> $GITHUB_OUTPUT

          echo "Plugin: $PLUGIN_NAME"
          echo "Project: $PROJECT_NAME"
          echo "Description: $PLUGIN_DESC"
          echo "Entry Point: $ENTRY_POINT"

      - name: Sanitize plugin.json
        run: |
          echo "üìù Preparing plugin.json for CI/CD deployment..."
          echo "This ensures NO credentials are included in the deployment ZIP"

          # Backup current plugin.json (has updated version)
          cp plugin.json plugin.version-updated.json

          # Copy plugin.json.example as base (without credentials)
          if [ -f "plugin.json.example" ]; then
            # Validate plugin.json.example is valid JSON
            if jq empty plugin.json.example 2>/dev/null; then
              cp plugin.json.example plugin.json
              echo "‚úÖ Copied plugin.json.example ‚Üí plugin.json"
            else
              echo "‚ùå ERROR: plugin.json.example is not valid JSON!"
              cat plugin.json.example
              exit 1
            fi
          else
            echo "‚ö†Ô∏è  Warning: plugin.json.example not found, using existing plugin.json"
          fi

          # Restore version from backup (with validation)
          VERSION=$(jq -r '.version' plugin.version-updated.json)
          if jq --arg version "$VERSION" '.version = $version' plugin.json > plugin.tmp.json && [ -s plugin.tmp.json ]; then
            mv plugin.tmp.json plugin.json
            echo "‚úÖ Restored version: $VERSION"
          else
            echo "‚ùå ERROR: Failed to restore version"
            rm -f plugin.tmp.json
            exit 1
          fi

          # Sanitize defaultSettings (empty all values for security)
          if [ -f "scripts/sanitize-plugin-json.mjs" ]; then
            node scripts/sanitize-plugin-json.mjs
            echo "‚úÖ Sanitized defaultSettings (all values emptied)"
          else
            echo "‚ö†Ô∏è  Warning: sanitize script not found, skipping sanitization"
          fi

          # Final validation
          if ! jq empty plugin.json 2>/dev/null; then
            echo "‚ùå ERROR: plugin.json is corrupted after sanitization!"
            exit 1
          fi

          # Show final plugin.json for verification
          echo ""
          echo "üìã Final plugin.json:"
          cat plugin.json
          echo ""

      - name: Build and publish plugin
        run: |
          echo "Building plugin..."

          # Validate project_name is set
          if [ -z "${{ steps.plugin_meta.outputs.project_name }}" ]; then
            echo "‚ùå ERROR: project_name is empty!"
            exit 1
          fi

          dotnet publish src/${{ steps.plugin_meta.outputs.project_name }}/${{ steps.plugin_meta.outputs.project_name }}.csproj -c Release -o publish

          echo "Build completed"
          ls -la publish/

      - name: Create ZIP package
        id: create_zip
        run: |
          PLUGIN_NAME="${{ steps.plugin_meta.outputs.name }}"
          VERSION="${{ steps.version.outputs.version }}"
          SHORT_HASH="${{ steps.build_metadata.outputs.short_hash }}"
          COMMIT_HASH="${{ steps.build_metadata.outputs.commit_hash }}"
          BUILD_DATE="${{ steps.build_metadata.outputs.build_date }}"

          ZIP_NAME="${PLUGIN_NAME}.${VERSION}-${SHORT_HASH}.zip"

          mkdir -p dist

          # Get release notes from git commit message
          RELEASE_NOTES=$(git log -1 --pretty=%B)

          # Get repository URL
          REPO_URL="${{ github.server_url }}/${{ github.repository }}"

          # Build URL for GitHub Actions
          BUILD_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          echo "Adding metadata to plugin.json:"
          echo "  - commitHash: $SHORT_HASH"
          echo "  - buildDate: $BUILD_DATE"
          echo "  - buildUrl: $BUILD_URL"
          echo "  - repositoryUrl: $REPO_URL"

          # Enrich plugin.json with all metadata (with validation)
          if jq --arg commitHash "$COMMIT_HASH" \
             --arg buildDate "$BUILD_DATE" \
             --arg releaseNotes "$RELEASE_NOTES" \
             --arg repositoryUrl "$REPO_URL" \
             --arg buildUrl "$BUILD_URL" \
             '. + {commitHash: $commitHash, buildDate: $buildDate, releaseNotes: $releaseNotes, repositoryUrl: $repositoryUrl, buildUrl: $buildUrl}' \
             plugin.json > plugin.enriched.json && [ -s plugin.enriched.json ]; then
            echo "‚úÖ Enriched plugin.json with metadata"
          else
            echo "‚ùå ERROR: Failed to enrich plugin.json"
            rm -f plugin.enriched.json
            exit 1
          fi

          # Create ZIP with published files + enriched plugin.json
          cd publish
          cp ../plugin.enriched.json ./plugin.json
          zip -r "../dist/${ZIP_NAME}" .
          cd ..

          echo "zip_name=$ZIP_NAME" >> $GITHUB_OUTPUT

          echo "Created: dist/${ZIP_NAME}"
          ls -la dist/

          # Verify plugin.json in ZIP is not empty
          echo ""
          echo "üìã Verifying plugin.json in ZIP:"
          unzip -p "dist/${ZIP_NAME}" plugin.json | head -20

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.plugin_meta.outputs.name }}-${{ steps.version.outputs.version }}
          path: dist/*.zip
          retention-days: 90

      - name: Commit version update
        run: |
          echo "üìù Committing version update..."

          # IMPORTANT: Restore the ORIGINAL plugin.json structure before committing
          # We need to commit plugin.json with the new version but WITHOUT defaultSettings
          # (defaultSettings should only exist in plugin.json.example)

          # Create a clean plugin.json with just the essential fields
          jq '{name, version, description, author, entryPoint, pluginClass}' plugin.version-updated.json > plugin.json

          # Validate before committing
          if ! jq empty plugin.json 2>/dev/null || [ ! -s plugin.json ]; then
            echo "‚ùå ERROR: plugin.json is invalid before commit!"
            cat plugin.json
            exit 1
          fi

          echo "üìã plugin.json to commit:"
          cat plugin.json

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add plugin.json

          if git diff --staged --quiet; then
            echo "‚ö†Ô∏è No version changes to commit"
          else
            git commit -m "chore: bump version to ${{ steps.version.outputs.version }} [skip ci]"

            echo "üì§ Pushing changes to repository..."

            if git push; then
              echo "‚úÖ Version update committed and pushed successfully"
            else
              echo "‚ùå Failed to push changes"
              exit 1
            fi
          fi

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.version }}
          name: ${{ steps.plugin_meta.outputs.name }} v${{ steps.version.outputs.version }}
          body: |
            ## ${{ steps.plugin_meta.outputs.name }} v${{ steps.version.outputs.version }}

            **Description**: ${{ steps.plugin_meta.outputs.description }}
            **Author**: ${{ steps.plugin_meta.outputs.author }}

            ### Build Info
            - **Commit**: [`${{ steps.build_metadata.outputs.short_hash }}`](${{ github.server_url }}/${{ github.repository }}/commit/${{ steps.build_metadata.outputs.commit_hash }})
            - **Build Date**: ${{ steps.build_metadata.outputs.build_date }}
            - **Workflow Run**: [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

            ### Installation

            1. Download `${{ steps.create_zip.outputs.zip_name }}`
            2. Go to **Admin Panel > Plugins > Upload Plugin**
            3. Upload the ZIP file
            4. Configure connection string if needed
            5. Activate the plugin

            ### API Endpoints

            Once activated, the plugin endpoints will be available at:
            ```
            /api/plugins/${{ steps.plugin_meta.outputs.name }}/*
            ```

            ---
            Generated with GitHub Actions
          files: |
            dist/${{ steps.create_zip.outputs.zip_name }}
          draft: false
          prerelease: false
